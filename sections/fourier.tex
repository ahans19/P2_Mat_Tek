\chapter{The Discrete Fourier Transform} \label{ch:DFT}
In this chapter the discrete Fourier transform (DFT) is defined and from this, the fast Fourier transform (FFT) is derived.\\

As mentioned in \autoref{sec:ParametersAudioRecognition}, when analysing music, it can be beneficial to look at a signal in the frequency domain. A continuous signal can be transformed into the frequency domain by using the Fourier transform. 
\\
The Fourier transform only works on continuous signals, however it is possible to define the discrete Fourier transform, which can be applied for sampled signals. 

\begin{definition}{The Discrete Fourier Transform}
    The DFT, transforms a discrete signal $f$ in the time domain with $N$ terms, into a discrete sequence $F$ in the frequency domain also with $N$ terms, which is defined as: 
    \begin{align*}
        F[k]=\sum^{N-1}_{n=0}f[n]e^{-2jnk\pi/N}.
    \end{align*}
    \cite[5]{rao2011fast}
    \label{def:DFT_definiton}
\end{definition}

\noindent In the following theorem it is shown, how the DFT can be represented as a matrix vector product.

\begin{theorem}{The Discrete Fourier Transform as a Matrix Vector Product}
    By defining
    \begin{align*}
        W_N=e^{-2j\pi/N},
    \end{align*}
    the DFT can then be written as:
    \begin{align*}
        F[k]=\sum^{N-1}_{n=0}f[n]W_N^{nk}.
    \end{align*}
    From this the $N\times N$ DFT matrix is defined as:
    \begin{align*}
        DFT_N=
        \begin{bmatrix}
             W_N^{0\cdot0} & W_N^{0\cdot1} & W_N^{0\cdot2} & \hdots & W_N^{0(N-1)} \\
             W_N^{1\cdot0} & W_N^{1\cdot1} & W_N^{1\cdot2} & \hdots & W_N^{1(N-1)} \\
             W_N^{2\cdot 0} & W_N^{2\cdot1} & W_N^{2\cdot2} & \hdots & W_N^{2(N-1)} \\
             \vdots & \vdots & \vdots & \ddots & \vdots \\
             W_N^{(N-1)0} & W_N^{(N-1)1} & W_N^{(N-1)2} & \hdots & W_N^{(N-1)(N-1)} \\
         \end{bmatrix}.
    \end{align*}
    The DFT of a vector $\textbf{x}$ can then be expressed as the linear transformation
    \begin{align*}
        \textbf{y}=DFT_N\textbf{x},
    \end{align*}
    where $\textbf{x} \in \mathds{R}^{N}$ and $\textbf{y} \in \mathds{C}^{N}$. \cite[10]{rao2011fast}
\end{theorem}

\noindent To compute the DFT, it is necessary to do $N^2$ computations. To reduce the amount of computations, the fast Fourier transform is used.

\section{The Fast Fourier Transform}
The Fast Fourier Transform (FFT) is a method of reducing the number of computations needed to calculate the DFT. This can be accomplished by reducing the DFT matrix to a product of sparse matrices. 
To do so the following theorem is needed.

\begin{theorem}{The DFT when $N$ is even}
    Let $\mathbf{y}=DFT_{N}\mathbf{x}$ be the $N$-point DFT of $\mathbf{x}$ where $N$ is even and let $D_{N/2}$ be an $(N/2)\times(N/2)$ diagonal matrix with entries 
    \begin{align}
        (D_{N/2})_{n,n}=W_N^n \quad \text{for} \quad 0 \leq n< N/2.
        \label{eq:DFTDiagonal}
    \end{align}
    It can then be written as:
    \begin{align*}
         \mathbf{y_1}&=DFT_{N/2}\mathbf{x}^{(e)}+D_{N/2}DFT_{N/2}\mathbf{x}^{(o)}\\ 
         \mathbf{y_2}&=DFT_{N/2}\mathbf{x}^{(e)}-D_{N/2}DFT_{N/2}\mathbf{x}^{(o)}.\\
    \end{align*}
    Where $\mathbf{y_1}$ is the first half $N/2$ entries of $\mathbf{y}$ and $\mathbf{y_2}$ is the second half of entries and $\mathbf{x}^{(e)}$ and $\mathbf{x}^{(o)}$ are the even and odd entries of $\mathbf{x}$ respectively. Hence $\mathbf{x}^{(e)},\mathbf{x}^{(o)}\in \mathds{R}^{N/2}$ and $\mathbf{y_1},\mathbf{y_2}\in \mathds{C}^{N/2}$. \cite[67]{ryan2019linear}
    \label{theo:DFT_N_even}
\end{theorem}
\begin{proof}{The DFT when $N$ is even}
From \autoref{def:DFT_definiton}:
    \begin{align*}
         F[k]&=\sum^{N-1}_{n=0}f[n]W_N^{nk}.\\
        \intertext{The sum of the DFT can be split into two sums, an even and an odd part.}\\
        &=\sum^{N/2-1}_{r=0}f[2r]W_N^{2rk}+\sum^{N/2-1}_{r=0}f[2r+1]W_N^{(2r+1)k}\\
        \intertext{This can be rewritten to $W_N^2$ and moving the constant $W_N^k$ out of the sum}
        &=\sum^{N/2-1}_{r=0}f[2r](W_N^2)^{rk}+W_N^k\sum^{N/2-1}_{r=0}f[2r+1](W_N^2)^{rk}.\\
        \intertext{Note that $W_N$ is defined as $e^{-2j\pi/N}$, hence}
        W_N^2 &= \exp\left(\frac{-j2(2\pi)}{N}\right) = \exp\left(\frac{-j2\pi}{N/2}\right) = W_{N/2}.\\
        \intertext{Thereby it yields:}
        F[k] &= \sum^{N/2-1}_{r=0}f[2r]W^{rk}_{N/2}+W^k_N\sum^{N/2-1}_{r=0}f[2r+1]W^{rk}_{N/2}.\\
    \end{align*}
    Using \eqref{eq:DFTDiagonal} where $0 \leq k < N/2$ the first half can be written as:
     \begin{align*}
        \mathbf{y_1}=DFT_{N/2}\mathbf{x}^{(e)}+D_{N/2}DFT_{N/2}\mathbf{x}^{(o)}.\\ 
     \end{align*}
    If $k$ is limited to $0 \leq k < N/2$, then the second half ($\mathbf{y_2}$) of the DFT can be processed using the same method as in the first half ($\mathbf{y}_1$):
    \begin{align*}
        F[k+N/2] &= \sum^{N-1}_{n=0}f[n]W_N^{n(k+N/2)}\\
        &=\sum^{N/2-1}_{r=0}f[2r]W_N^{2r(k+N/2)}+\sum^{N/2-1}_{r=0}f[2r+1]W_N^{(2r+1)(k+N/2)}\\
        &=\sum^{N/2-1}_{r=0}f[2r](W_N^2)^{r(k+N/2)}+W_N^{k+N/2}\sum^{N/2-1}_{r=0}f[2r+1](W_N^2)^{r(k+N/2)}\\
        W_N^{N/2}&=\exp\left(\frac{-j2\pi}{N}\frac{N}{2}\right)=\exp\left(-j\pi\right)=-1\\
        F[k+N/2] &=\sum^{N/2-1}_{r=0}f[2r]W_{N/2}^{r(k+N/2)}-W_N^{k}\sum^{N/2-1}_{r=0}f[2r+1]W_{N/2}^{r(k+N/2)}.\\
    \end{align*}
    This can be written using \eqref{eq:DFTDiagonal} where $0 \leq k < N/2$ as:
    \begin{align*}
        \mathbf{y_2}=DFT_{N/2}\mathbf{x}^{(e)}-D_{N/2}DFT_{N/2}\mathbf{x}^{(o)}.\\ 
     \end{align*}
     \cite[67]{ryan2019linear}
\end{proof}
From Theorem \ref{theo:DFT_N_even} the DFT of $\textbf{x}$ can be expressed as: 
\begin{align*}
    \mathbf{y}=
    \begin{bmatrix}
        \mathbf{y_1}\\
        \mathbf{y_2}
    \end{bmatrix}
    &=
    \begin{bmatrix}
        DFT_{N/2} & D_{N/2}DFT_{N/2} \\
        DFT_{N/2} & -D_{N/2}DFT_{N/2}
    \end{bmatrix}
    \begin{bmatrix}
        \mathbf{x}^{(e)} \\
        \mathbf{x}^{(o)}
    \end{bmatrix}\\
    &=
    \begin{bmatrix}
        I_{N/2} & D_{N/2} \\
        I_{N/2} & -D_{N/2}
    \end{bmatrix}
    \begin{bmatrix}
        DFT_{N/2} & \mathbf{0} \\
        \mathbf{0} & DFT_{N/2}
    \end{bmatrix}
    \begin{bmatrix}
        \mathbf{x}^{(e)} \\
        \mathbf{x}^{(o)}
    \end{bmatrix}.
\end{align*}
If $N/2$ is even then $DFT_{N/2}$ can be factored into:
\begin{align*}
        \mathbf{y}=
    \begin{bmatrix}
        I_{N/2} & D_{N/2} \\
        I_{N/2} & -D_{N/2}
    \end{bmatrix}
    \begin{bmatrix}
        I_{N/4} & D_{N/4} & \mathbf{0} & \mathbf{0} \\
        I_{N/4} & -D_{N/4} & \mathbf{0} & \mathbf{0} \\
        \mathbf{0} & \mathbf{0} & I_{N/4} & D_{N/4}  \\
        \mathbf{0} & \mathbf{0} & I_{N/4} & -D_{N/4} \\
    \end{bmatrix}\times\\
    \begin{bmatrix}
        DFT_{N/4} & \mathbf{0} & \mathbf{0} & \mathbf{0} \\
        \mathbf{0} & DFT_{N/4} & \mathbf{0} & \mathbf{0} \\
        \mathbf{0} & \mathbf{0} & DFT_{N/4} & \mathbf{0} \\
        \mathbf{0} & \mathbf{0} & \mathbf{0} & DFT_{N/4} \\
    \end{bmatrix}
    \begin{bmatrix}
        \mathbf{x}^{(ee)} \\
        \mathbf{x}^{(eo)} \\
        \mathbf{x}^{(oe)} \\
        \mathbf{x}^{(oo)}
    \end{bmatrix},
\end{align*}
where $\mathbf{x}^{(e)}$ and $\mathbf{x}^{(o)}$ are split into even and odd parts.  
If $N$ is limited to be $N=2^L$, where $L$ is an positive integer. Then $DFT_N$ can be factored $L=\log_2 N$ times. When factorising $\log_2 N$ times, the final matrix becomes a diagonal matrix with entries $DFT_1=[1]$, which is the identity matrix. Hence it is only necessary to factor the matrix $\log_2(N) - 1$ times. \cite[68-69]{ryan2019linear}\\
This can be generalised as
\begin{align*}
    DFT_N=\prod_{k=1}^{\log_2 N}\left(
    \begin{bmatrix}
    I_{N/2^k}  & D_{N/2^k}  & \mathbf{0} & \mathbf{0} & \hdots & \mathbf{0} & \mathbf{0}\\
    I_{N/2^k}  & -D_{N/2^k} & \mathbf{0} & \mathbf{0} & \hdots & \mathbf{0} & \mathbf{0}\\
    \mathbf{0} & \mathbf{0} & I_{N/2^k}  & D_{N/2^k}  & \hdots & \mathbf{0} & \mathbf{0}\\
    \mathbf{0} & \mathbf{0} & I_{N/2^k}  & -D_{N/2^k} & \hdots & \mathbf{0} & \mathbf{0}\\
    \vdots     & \vdots     & \vdots     & \vdots     & \ddots & \vdots     & \vdots    \\
    \mathbf{0} & \mathbf{0} & \mathbf{0} & \mathbf{0} & \hdots & I_{N/2^k}  & D_{N/2^k} \\
    \mathbf{0} & \mathbf{0} & \mathbf{0} & \mathbf{0} & \hdots & I_{N/2^k}  & -D_{N/2^k}
    \end{bmatrix}
    \right)P.
\end{align*}
To split the input vector into the even and odd parts of the transformation, a $N\times N$ permutation matrix, $P$, is used. To illustrate how to determine $P$, the following example is used. 

\begin{example}{Bit Reversal}
    A $DFT_8$ can be factored $\log_2 8-1=2$ times. Which means that the input vector needs to be split into odd and even values twice. This is illustrated below:
    \begin{align*}
        \begin{bmatrix}
            x_0 \\
            x_1 \\
            x_2 \\
            x_3 \\
            x_4 \\
            x_5 \\
            x_6 \\
            x_7
        \end{bmatrix}
        \rightarrow
        \begin{bmatrix}
            x_0 \\
            x_2 \\
            x_4 \\
            x_6 \\
            x_1 \\
            x_3 \\
            x_5 \\
            x_7
        \end{bmatrix}
        \rightarrow
        \begin{bmatrix}
            x_0 \\
            x_4 \\
            x_2 \\
            x_6 \\
            x_1 \\
            x_5 \\
            x_3 \\
            x_7
        \end{bmatrix}.
    \end{align*}
    It is observed that, if using the binary representation of the indexes of the first vector, then bit reversing it, the indexes of the last vector is obtained. For instance the binary representation of $3=011_2$ and when reversing the bits, $110_2=6$. Therefore, the sixth index will be placed in third index of the final vector.
    
    To represent the example as a matrix, the values from the first vector need to be transformed into the third vector by multiplying with the following matrix:
    \begin{align*}
        P&=
        \begin{bmatrix}
            1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
            0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
            0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
            0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\
            0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
            0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
            0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
            0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
        \end{bmatrix}\\
        &=\begin{bmatrix}
        \mathbf{e}_1 & \mathbf{e}_5 & \mathbf{e}_3 & \mathbf{e}_7 & \mathbf{e}_2 & \mathbf{e}_6 & \mathbf{e}_4 & \mathbf{e}_8
        \end{bmatrix}.
 \end{align*}
   As seen $P$ is represented as a $N \times N$ matrix, where the columns contains unit vectors $\mathbf{e}_{i+1}$ respectively, where $i$ is the bit reversed index number from $0$ to $N-1$.
    \label{exa:bitreverse}
\end{example}
From Example \ref{exa:bitreverse}, it can be generalised that $P$ is represented as a $N \times N$ matrix, where the columns contain the unit vector $\mathbf{e}_{i+1}$ from the bit reversed vector respectively.
%\section{inverse FFT?}

% \section{Comparison between the DFT and the FFT}
% To compare the computations required in FFT and DFT the amount of computations required are described in the following \cite[72]{ryan2019linear}
% \begin{align*}
%     FFT = 2Nlog_2N \qquad DFT = 8N^2.
% \end{align*}
% As seen the computations required for the DFT is significantly higher than the computations required for the FFT. Therefore, in practise it is more beneficial to use the FFT.